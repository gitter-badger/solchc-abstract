\section{Background}

Here we present the background material of our work: the Solidity language, in Section \ref{sec:background_sol}, control-flow graphs, in Section \ref{sec:background_cfg}, and constrained Horn clauses, in Section \ref{sec:background_chc}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Solidity} \label{sec:background_sol}

Solidity is a Turing-Complete language for the development of smart contracts. The two main elements of Solidity are contracts and functions, which we now describe; detailed information on Solidity can be found in \cite{}. 

\paragraph{Contracts.} A Solidity contract is a structure similar to a class in object-oriented languages, and can contain both data and functions. Data can range from integer and boolean values to arrays and structs. Functions contain the instructions for computation. A contract does not have a main function, instead all functions with appropriate visibility can be called once the contract is deployed on the blockchain.

\paragraph{Functions.} A function in a contract contains a sequence of statements for computation. Most operators that are common in programming languages, such as conditionals and loops, are supported. Function qualifiers include visibility and access to state variables. 

\paragraph{} As a running example, consider contract \texttt{C} shown in Figure \ref{fig:contractC}. This contract has two state variables of type unsigned int, \texttt{sum} and \texttt{count}, and two functions. The first function is a fallback function, it has no name and is executed when the contract is called without specifying one of its named functions; \texttt{external} specify that the function can only be called from outside the contract, while \texttt{payable} allows the function to receive ether. The \texttt{average} function follows the standard format, returning an unsigned integer at the end of its execution; \texttt{public} specify that the function can be called both from inside and outside the contract, and \texttt{view} ensures that the state variables are not modified.

\begin{figure}
\lstinputlisting{contract.txt}
\caption{An example of a contract written in Solidity}
\label{fig:contractC}
\end{figure}

The fallback function accepts a certain value in ether, \texttt{msg.value}, adds this value to \texttt{sum}, and increase the counter. Two \texttt{require} assertions are present, the first one checks if the sent value is positive, an the second one ensures that overflow will not occur. This type of assertion works as a pre-condition, usually used to check inputs.

The \texttt{average} function calculates and returns the average of deposits of ether. Two assertions are present, the first one checks if there is at least one deposit, and the second one ensure that the average positive. The \texttt{assert} works as a post-condition, meaning that its predicate should never be false in a valid execution, with a violation capturing an error in the code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Control-Flow Graph} \label{sec:background_cfg}

A control-flow graph is way to model a program such that all execution paths are explicitly present and can be analysed. There are two elements that constitute a control-flow graph: basic blocks and transitions.

\paragraph{Basic Blocks.} These are the nodes of the graph. They represent a number of sequential statements that do not influence the execution flow of the program, such as assignments. The statements represented by the node have their order maintained and can be retrieved during analysis.

\paragraph{Transitions.} These are the edges of the graph. They represent control flow structures such as conditionals and while-loops. Associated with each transition is a predicate that must be evaluated to "true" for the transition to taken. Transitions never occur in isolation, since basic blocks with in-degree and out-degree of one can be merged with an adjacent block. To avoid nondeterminism and ensure that one transition can always be taken from a particular node, the disjunction of the predicates of all transitions starting in it need to be "true", and their conjunction needs to "false".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Constrained Horn Clauses} \label{sec:background_chc}

Constrained Horn clauses are disjunctions of literals with at most one positive literal. They can be written in implication form and be used for program verification. When describing a piece of code, rules are created with the following structure:

\begin{align*}
SSA \land Condition \land Current\_Relation \implies Next\_Relation
\end{align*}

The \texttt{SSA} captures the Single Static Assignment of the variables in code being modelled, and it is written as a conjunction of equalities. The \texttt{Condition} states the condition of a control-flow structure, such as a conditional. The \texttt{Current\_Relation} and \texttt{Next\_Relation} represent points in the code, in way that by applying the rules it is possible to simulate an execution. The only mandatory field is \texttt{Next\_Relation}, with the most simplified rule being the one with just the start relation.

Horn clauses can be linear, also called constrained, or non-linear, the former has only rules with a one to one link between relations, while the former allows for many to one links, with many relations on the left hand side of the implication. In this work we consider only constrained Horn clauses.

%\begin{figure}
%\lstinputlisting{chc.txt}
%\caption{to do}
%\label{fig:chcC}
%\end{figure}