\section{Solidity to Control-Flow Graph}

Here we describe how we model Solidity programs as control-flow graphs. First we discuss how to model individual functions, in Section \ref{sec:sol_cfg_fun}, and then, in Section \ref{sec:sol_cfg_con}, the general approach for modeling a whole contract is presented.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Control-Flow Graph of a Solidity Function} \label{sec:sol_cfg_fun}

To generate the control-flow graph of a Solidity function we initially create an entry node and an exit node. Every node represents a basic block of the original program. Starting at the entry node we scan the code until a control structure is reached. At this point the statements collected are stored in the basic block and transitions to new nodes are created according to the control structure reached. At the end, when the last line of code of a path is scanned, a transition is added to the exit node; multiple paths are created by multiple return statements.

The shape of the resulting graph depends of the control structures in the code. The graphs generate by some common control structures are shown in Figure \ref{}. The Solidity assertions are treated according to their function. The \texttt{require} operator works as a pre-condition, and in our encoding does not influence the shape of the graph, being added as a condition inside the basic blocks. The \texttt{assert} operator works as a post-condition, and is encoded as a conditional with the transition associated with its condition targeting the next basic block in the graph, and the transition associated with the negation of the condition targeting an error node. The error node works as a sink in our model, and reaching it represents an error in the execution. An example of our encoding of assertions can be seen in Figure \ref{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Control-Flow Graph of a Solidity Contract} \label{sec:sol_cfg_con}

Unlike programming languages such as C++ and Java, Solidity does not have a main function, the functions of a given contract can be called independently and in any order. To capture the behaviour of a whole contract in a single control-flow graph, we create an infrastructure to model calls to functions, as can be seen in Figure \ref{}.

The entry node of the graph models the constructor of the contract, which is a special function that is executed before deploying the contract on the blockchain, with the goal of initializing state variables. From the constructor only one transition is possible, to the interface node, which is an internal node that targets the entry node of each function in the contract. To represent the fact that the contract functions can be called in any order, the transitions starting at the interface are nondeterministic, with their predicates being simply "true". To allow for many function calls, the exit node of each function targets the interface node.

The final point to consider is the use of assertions. The \texttt{require} operator is handled as previously described, since it does not influence the control-flow. The \texttt{assert} operator, however, now targets a global error state, instead of a specific one for each function. This change makes checking the contract easier, since we only need verify if one particular state can be reached. 