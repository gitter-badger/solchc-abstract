\section{Solidity to Control-Flow Graph}

In this section we describe how we model Solidity programs as control-flow graphs. First we discuss how to model individual functions, in Section \ref{cfg_fun}, and then, in Section \ref{cfg_con}, the general approach for modeling a whole contract is presented.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Control-Flow Graph of a Solidity Function} \label{cfg_fun}

To generate the control-flow graph of a Solidity function we initially create an entry node and an exit node. Every node represents a basic block of the original program. Starting at the entry node we scan the code until a control structure is reached. At this point the statements collected are stored in the basic block and transitions to new nodes are created according to the control structure reached. At the end, when the last line of code of a path is scanned, a transition is added to the exit node.

The shape of the resulting graph depends of the control structures in the code. The graphs generate by some common control structures are shown in Figure \ref{}; each transition is associated with a predicate derived from a control structure. When a function has zero or one return statement, there is only one transition targeting the exit node, when multiple returns are present we have more than one of such transitions, as can be seen in Figure \ref{}. 

Solidity has built-in assertion operators. The \textit{require} operator works as a pre-condition, and in our encoding of Solidity does not influence the shape of the graph, being added as a condition inside the basic blocks. The \textit{assert} operator works as a post-condition, and is encoded as a conditional with the transition associated with its condition targeting the next basic block in the graph, and the transition associated with the negation of the condition targeting an error node. The error node works as a sink in our model, and reaching it represents an error in the execution. An example of our encoding can be seen in Figure \ref{}; more information regarding Solidity assertions can be found in its documentation \cite{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Control-Flow Graph of a Solidity Contract} \label{cfg_con}

Unlike programming languages such as C++ and Java, Solidity does not have a main function, the functions of a given contract can be called independently and in any order. To capture the behaviour of a contract in a single control-flow graph, we create an infrastructure to model calls to functions, as can be seen in Figure \ref{}.

The entry node models the constructor of the contract, which is a function that is executed before deploying the contract on the blockchain, with the goal of initializing state variables. From the constructor only one transition is possible, to the invocation node. The invocation node is an internal node that targets the entry node of each function in the contract; the predicate of all its transitions are "true". To represent the fact that the contract is in the blockchain and functions can be called in any order, the exit node of each function targets the invocation node, closing a loop.

The final point to consider is the use of assertions. The \textit{require} operator is handled as previously described, since it does not influence the control-flow. The \textit{assert} operator, however, now targets a global error state, instead of a specific one for each function. This change makes checking the contract easier, since we only need verify if one particular state can be reached. 