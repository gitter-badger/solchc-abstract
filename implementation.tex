\newpage
\section{Implementation}

A prototype tool was developed to allow the application of our technique. It is implemented on top of the Solidity compiler and allows the automatic generation of constrained Horn clauses for a given Solidity contract, which can then be supplied to off-the-shelf Horn clause solvers.

The clause generation occurs during the compilation process and has two steps. First, the prototype traverses the AST of the contract and constructs the control flow graph representing it; for ease of implementation we construct a single graph for the whole contract, instead of individual graphs for each function. The second step is to generate the constrained Horn clauses from the control flow graph constructed. The CFG is a suitable intermediate structure that can be easily constructed from the AST and that allows for a direct mapping into Horn clauses.

The CFG of a given Solidity contract is constructed by first defining global entry and error blocks, together with the interface block. The entry block represents the start of the contract and models a call to the constructor, Eq. \ref{eq:CHC-constructor-initial}. The interface block allows calls to the contract functions in nondeterministic order, directly modelling the $\conP(\svar)$ predicate; its outward and inward edges model Eq. \ref{eq:CHC-call-initial} and Eq. \ref{eq:CHC-call-final}, respectively. Instead of local error states for each function, the prototype creates a single global error state for the whole contract.

For each function, local entry and exit blocks are created, linked to the interface block. From the entry block, new blocks are created every time a control structure, such as a conditional or a loop, is reached; the position of the edges, and thus the topology of the graph, depend on the semantics of each control structure in the function.

Each block is associated with a conjunction of statements, modelling $\lambda$, which can be assignments or \texttt{require} statements; an empty block, such as the interface, is a block that is not associated with any line of code, and do not change the state of the program.

The prototype currently supports a subset of the Solidity language. Most basic operators and assertions are supported. Integer variables and operations are fully supported, and arrays are partially supported. Function calls, recursive or otherwise, additional types, such as booleans and strings, are not yet supported.

%Given a current node $m \in V$, the occurrence of a while loop, for example, leads to the creation of four new nodes $loop1, loop2, loop3, n \in V$, with $loop1$ capturing the loop condition, $loop2$ and $loop3$ modelling the start the end of its body, and $n$ being the first block after the loop. The edge $\langle m, loop1 \rangle$ models the start of the loop, $\mu(\langle m, loop1 \rangle) = true$, the edge $\langle loop1, loop2 \rangle$ models the start of the body of the loop, $\mu(\langle m, loop1 \rangle) = condition$, the edge $\langle loop2, loop3 \rangle$ models the end of the body of the loop, $\mu(\langle loop3, loop1 \rangle) = true$, and the edge $\langle loop3, m \rangle$ models the exit of the loop $\mu(\langle m, loop1 \rangle) = \neg condition$.