\section{Implementation}

Our implementation is based on the Solidity compiler. Given a Solidity contract, the constrained Horn clauses representing it are generated by traversing its AST. For ease of implementation, we create a control flow graph of the contract as a whole, instead of individual graphs for each function, and we consider a single global error state, instead of local error states for each function; these changes do not affect the soundness of our approach.

Each basic block is associated with a conjunction of statements, modelling $\lambda$, which can be assignments or \texttt{require} statements; an empty block is a block that is not associated with any line of code, and do not change the state of the program. 

For a given function, besides its entry and exit nodes, new nodes are created whenever a control flow structure, such as a conditional or a loop, is found. For each structure, new nodes are created with their appropriate edges.

Given a current node $m \in V$, the occurrence of a while loop, for example, leads to the creation of four new nodes $loop1, loop2, loop3, n \in V$, with $loop1$ capturing the loop condition, $loop2$ and $loop3$ modelling the start the end of its body, and $n$ being the first block after the loop. The edge $\langle m, loop1 \rangle$ models the start of the loop, $\mu(\langle m, loop1 \rangle) = true$, the edge $\langle loop1, loop2 \rangle$ models the start of the body of the loop, $\mu(\langle m, loop1 \rangle) = condition$, the edge $\langle loop2, loop3 \rangle$ models the end of the body of the loop, $\mu(\langle loop3, loop1 \rangle) = true$, and the edge $\langle loop3, m \rangle$ models the exit of the loop $\mu(\langle m, loop1 \rangle) = \neg condition$.

The shape of the resulting graph depends of the control structures present in the function. Each condition generates an empty node with two outward edges, one with the condition itself, and one with its negation. Control structures can be combined to model complex scenarios, such as nested loops.

The encoding of the Solidity assertions is done according to their semantics. The \texttt{require} operator works as a pre-condition, and is thus simply added inside the current node. The \texttt{assert} operator works as a post-condition, and is encoded as a conditional with the \texttt{then} branch targeting the next node in the graph, and the \texttt{else} branch targeting the error node.

The implementation supports a subset of Solidity. Function calls, recursive or otherwise, are not supported.

Solidity contracts do not have a main function, once deployed to the blockchain all their functions, with the appropriate visibility, can be called many times and in any order. To capture this behaviour in a single control-flow graph, we create an interface node.

The entry node of the graph is the constructor of the contract, which is a special function that is executed before deploying the contract on the blockchain, with the goal of initializing state variables.


